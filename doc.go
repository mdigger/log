// Package log является простейшим вариантом структурного лога.
//
// Вообще, это очередной "велосипед", только с блекджеком и шлюхами. Причем
// абсолютно не претендующий на скоростную запись лога или потребление как
// можно меньшего количества памяти: сделано исключительно для себя с целью
// удобства использования.
//
// В основе лежит понятие обработчика лога (Handler), который отвечает за вывод
// и формат представления лога. Библиотека стандартно поддерживает несколько
// обработчиков для записи в io.Writer в разных форматах (StreamHandler). Если
// необходимо передавать записи лога в какую-то систему или сервис, или
// записывать их в базу данных, то проще всего реализовать свой собственный
// Handler.
//
// StreamHandler поддерживает разные форматирования лога, который реализованы
// с помощью StreamFormatter. В библиотеке реализованы консольное (текстовое)
// представление лога (Console) и в формате JSON. Текстовое представление
// может до некоторой степени настраиваться: в качестве примера смотри Color.
//
// Все записи, в первую очередь, делятся по уровню - Level. В библиотеке
// предопределены следующие уровни: TRACE (-64), DEBUG(-32), INFO(0), WARN(32) и
// ERROR(64). Они задают некоторые диапазоны уровней:
// 	TRACE: [-127 ... -31]
// 	DEBUG: [-32  ...  -1]
// 	INFO:  [0    ...  31]
// 	WARN:  [32   ...  63]
// 	ERROR: [64   ...  95]
// 	FATAL: [96   ... 127]
// Level.String() возвращает название диапазона: "TRACE", "DEBUG", "INFO",
// "WARN", "ERROR" и "FATAL".
//
// Кроме этого, записи можно разбивать на именованные категории [category]. По
// умолчанию категория имеет значение пустой строки. Обычно категории
// используются, если вы хотите визуально сразу разделить записи в лог по тому,
// к какому действию они относятся. Например, разделить обработчики
// HTTP-запросов от обращения к базе данных. Для создания новой категории
// используется метод Logger.New("name"). Соответственно, все вызовы методов
// записи лога с созданной категорией будут добавлять ее имя в лог.
//
// Запись в лог осуществляется методом Logger.Log(lvl, msg), в котором
// указывается уровень сообщения и его текст. Для большего удобства
// предопределены так же методы Logger.Debug(msg), Logger.Info(msg),
// Logger.Warn(msg) и Logger.Error(msg), которые подставляют соответствующий
// уровень сообщения самостоятельно. Logger.Trace и Logger.Fatal я пока
// намеренно не стал определять, так как, возможно, захочу добавить в них
// некоторую "специальную" логику. Logger.Warn и Logger.Error возвращает
// ошибку, сформированную на основании текста лога, чтобы ее можно было
// использовать в своем коде. А Logger.IfErr(err, msg) принимает в качестве
// параметра значение ошибки и выводит запись в лог с уровнем ERROR только в том
// случае, если ошибка не пустая (nil), и возвращает ее без каких либо
// изменений.
//
// Достаточно часто для лога важен контекст, который не всегда можно описать
// только одним названием категории. Для этого лог поддерживает дополнительные
// именованные поля с произвольными значениями (Fields). Для задания таких полей
// существуют методы Logger.WithField(name, value) и Logger.WithFields(fields),
// в котором вы можете перечислить сразу несколько именованных полей.
// Специальные методы Logger.WithError(err) и Logger.WithSource() добавляют
// именованные поля "err" и "src", в которые, соответственно, записываются текст
// ошибки или информация об имени исходного файла и номера строки, где был
// сделан данный вызов. Ошибка добавляется только в том случае, если она не
// пустая (nil). Методы могут вызывать несколько раз, пока вы не сформируете
// полное представление записи лога:
// 	log.WithError(err).WithField("name", 3).Debug("test")
// 	log.New("category").WithFields(log.Fields{"name": "test", "param": 3}).Info("info")
//
// Чтобы не быть таким многословным, существует более короткий путь для записи,
// который позволяет перечислить дополнительные именованные параметры сразу
// одним вызовом:
// 	log.Info("info message", "name", "test", "param", 3)
// Конечно, это накладывает некоторые ограничения и требует большей аккуратности
// при перечислении имен и значений, но, по-моему, оно того стоит.
//
// Еще один момент, на который необходимо обратить внимание: иногда бывает, что
// в коде уже используется вывод в стандартный лог. А стандартный лог является
// объектом, а не интерфейсом, поэтому переопределить его на свой лог не
// получится. Например, http.Server имеет свойство ErrorLog, которое требует
// именно значения стандартного лога. Специально для этого я предусмотрел
// метод Logget.StdLog(level, category), который возвращает стандартный лог,
// запись в который перехватывается и перенаправляется в исходный. При этом
// автоматически для всех записей устанавливается заданный уровень и имя
// категории. Конечно, это не является панацеей, но лучшего способа я пока не
// придумал.
//
// Для удобства использования библиотека инициализирует консольный лог по
// умолчанию, который настроен на вывод записей в os.Stderr, а методы работы
// с ним продублированы в качестве "корневых".
package log
